<div x-data="{ prompt: '', loading: false, abortController: null }">
    <textarea
        class="border-2 rounded-lg w-full resize-none p-2"
        rows="20"
        x-model="prompt"
        x-ref="textinput"
        placeholder="Type here..."
        :disabled="loading"
        @keydown.cmd.enter.prevent="await generateTextAndUpdateUI($data)"
        @keydown.ctrl.enter.prevent="await generateTextAndUpdateUI($data)"
    ></textarea>

    <div class="mt-2 w-full flex justify-center gap-4">
        <button
            class="bg-blue-500 disabled:bg-yellow-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline"
            x-text="loading ? 'Stop' : 'Generate'"
            :disabled="!prompt"
            @click="await generateTextAndUpdateUI($data)"
        ></button>
        <button
            :disabled="!prompt || loading"
            class="bg-blue-500 disabled:bg-yellow-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline"
            @click="prompt = wrapSelectedText($refs.textinput, '[INST]', '[/INST]')"
        >
            As Instruction
        </button>
    </div>
</div>

{{ template "views/partials/generate-text-script" }}

<script>
    'use strict';

    async function generateTextAndUpdateUI($data) {
        if ($data.loading) {
            $data.abortController.abort();
            return;
        }

        $data.loading = true;
        $data.abortController = new AbortController();

        // preprocess prompt
        if (!$data.prompt.startsWith('<s>')) {
            $data.prompt = '<s>' + $data.prompt;
        }

        if ($data.prompt.endsWith('</s>')) {
            $data.prompt = $data.prompt.slice(0, -'</s>'.length);
        }

        let lastToken;
        let lastTokenCount = 0;

        const tokenStream = generateText(
            $data.prompt,
            $data.abortController.signal
        );

        for await (const token of tokenStream) {
            $data.prompt += token;

            if (token === lastToken) {
                lastTokenCount++;
            } else {
                lastToken = token;
                lastTokenCount = 1;
            }
        }

        if (lastTokenCount > 1) {
            $data.prompt = $data.prompt.slice(0, -lastToken.length);
            $data.prompt += '</s>';
        }

        $data.loading = false;
    }

    function wrapSelectedText(textarea, prefix, suffix) {
        let startPos = textarea.selectionStart;
        let endPos = textarea.selectionEnd;

        if (startPos === endPos) {
            startPos = 0;
            endPos = textarea.value.length;
        }

        const textBefore = textarea.value.slice(0, startPos);
        const selectedText = textarea.value.slice(startPos, endPos);
        const textAfter = textarea.value.slice(endPos);

        let updatedText = textBefore;

        if (textBefore.endsWith(prefix) || selectedText.startsWith(prefix)) {
            updatedText += selectedText;
        } else {
            updatedText += prefix + selectedText;
        }

        if (textAfter.startsWith(suffix) || selectedText.endsWith(suffix)) {
            updatedText += textAfter;
        } else {
            updatedText += suffix + textAfter;
        }

        return updatedText;
    }
</script>
